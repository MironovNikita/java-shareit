package ru.practicum.shareit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ShareItApp {

    public static void main(String[] args) {
        SpringApplication.run(ShareItApp.class, args);
    }

    /*
    Семён, привет! Спасибо за замечания, как всегда, всё по делу)
    Стараюсь отдыхать, но времени всё меньше и меньше на это(( ТЗ отправляю тоже по ночам в основном((

    Теперь по порядку:
    1) BookingController (в ItemController тоже):
    В HEADER_USER_ID прописал final, потому что @RequestHeader упорно не хочет принимать ничего, кроме константы. Самое
    интересное, что как я ни пытался это условие соблюсти, ничего кроме "java: element value must be a constant
    expression" не получал. Я даже пробовал аннотацию Lombok @val для определения констант, не помогло. Возможно, ещё
    аннотация @FieldDefaults не доведена до идеала, не знаю) Пока принял решение просто убрать условие makeFinal и
    прописать final вручную. Так всё работает. Возможно, подскажешь что-то на этот счёт?

    2) BookingDatesDto:
    По @Data. Если я правильно понял ход твоих мыслей, то @Data логичнее. Т.к. наш DTO используется сейчас в простом
    формате, то поэтому final-поля работают без проблем. Но. Если вдруг этот DTO будет использоваться где-то ещё, и
    количество полей будет расширено в соответствии с расширением функционала, то логичнее сделать возможность
    корректировки полей DTO-объекта для корректной работы. Поправь, если я мыслю не в том направлении)

    3) BookingDto:
    Здесь я бы оставил @Value. По сути тут id вещи для аренды и даты её бронирования + статус. На протяжении выполнения
    запроса мы данный DTO не меняем, соответственно и поля могут быть final. Но это по моей логике, возможно я ошибаюсь.
    Что касается валидации времени - согласен на все 100%! Тут моя ошибка, я это пропустил. Добавил, спасибо!
    BookingStatus также добавил.

    4) Booking:
    Честно говоря, не думал, что в модели нужны проверки валидации, т.к. мы их по идее делаем в DTO. Если можно,
    поясни, пожалуйста этот момент.
    Пометил start и end @NotNull. Почитал про разницу: @NotNull позволяет выполнить проверку данных до того, как
    Hibernate отправит запрос в БД, что по сути снижает нагрузку на саму БД. Т.е. проще "на месте" проверить данные,
    чем "везти" их куда-либо и проверять там.
    BookingStatus не стал помечать @NotNull, т.к. в postman-запросах на создание бронирования не приходит статус.

    5) BookingRepository:
    :D Комментарии я для себя писал, чтобы разделить их для своего удобства. Когда методов много, они стали сливаться,
    вот я и разделил их таким своеобразным образом) Убрал комментарии и тут, и в BookingService.

    6) BookingService, ItemService и UserService:
    Я начал сразу делать функционал сервиса, без интерфейса, и по сути, когда всё заработало, решил так оставить. Хотя
    по ТЗ есть требование создания непосредственно классов ***ServiceImpl... Переделал, добавил интерфейсы сервисов,
    что более грамотно, т.к. какой-то метод можно просто забыть, либо же сделать ещё какой-либо сервис на основе данных
    методов.

    7) По логированию я, честно говоря, сам не обращал на это внимания... Где-то применял заполнитель, где-то делал
    через конкатенацию. Если спросишь, каким принципом я руководствовался - я не отвечу, не знаю) Но впредь запомню,
    буду делать всё логирование через placeholder. Поправил везде)
    Кстати, не подскажешь, как можно сделать логирование при использовании метода orElseThrow?
    По String.format - поправил, убрал конкатенацию по максимуму)

    8) Продолжая BookingService:
    Убрал boolean-проверки по времени старта/конца. Аннотации, конечно, решают многое в коде!

    9) Про кастомные аннотации спасибо огромное! Я давно на них смотрю, но руки не доходят. Скачаю код, поиграюсь с
    этим. За ссылку спасибо!

    10) По методу bookingRepository.save(booking) в BookingService.update:
    Я проверил, в случае, если я уберу вызов save - валятся тесты по статусу прежде всего, т.е. обновления не
    происходит :(

    11) Comment и CommentDto:
    Честно говоря, думал, что аннотации валидации полезны только при том случае, когда применяется аннотация
    @Valid/@Validated. В остальных моментах думал, что они не работают... Также думал, что имеет смысл прописывать их
    только в DTO, т.к. модель уже формируется из DTO, т.е. уже из проверенной сущности, скажем так. Добавил необходимые
    аннотации)

    12) ItemController:
    По сути та же история, что и в BookingController. См. пункт 1)

    13) Ограничения текстовых полей в соответствии с БД также добавил :)
    Это касается и User, и Item. Также добавил валидации email.

    14) ItemService (метод update):
    Проверки на null названия, описания и доступности нужны, т.к. в тестах проверяется обновление каждого поля по
    отдельности, т.е. в теле может приходить только имя/описание или статус доступности.

    15) ItemService (метод update):
    Та же история, что и в 10 пункте. Если убрать save - падают тесты((

    16) ItemService:
    Фильтрация нужна, т.к. у нас может быть несколько бронирований, удовлетворяющих требованиям. И из них нужно выбрать
    самые ближние к текущему моменту.

    17) По @Transactional:
    Согласен, это полезная штука. Добавил её в ItemService, BookingService и UserService.

    18) По UserService.update:
    Проверки имени и почты также нужны, т.к. мы можем получить отдельно или имя, или почту для обновления.

    Вроде бы всё :) Спасибо большое за ёмкую и тщательную проверку! Узнал много нового на самом деле!) Буду ждать ревью!
    P.S. Надеюсь, данный текст не сильно большой) Старался по максимуму всё разложить)
     */
}